var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = AtomsUtilityCalculators","category":"page"},{"location":"#AtomsUtilityCalculators","page":"Home","title":"AtomsUtilityCalculators","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for AtomsUtilityCalculators.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [AtomsUtilityCalculators]","category":"page"},{"location":"#AtomsUtilityCalculators.CombinationCalculator","page":"Home","title":"AtomsUtilityCalculators.CombinationCalculator","text":"CombinationCalculator{N}\n\nYou can combine several calculators to one calculator with this. Giving keyword argument executor=SequentialEx() toggles on multithdeaded execution of calculators. Using executor=DistributedEx() executes calculators using multiprocessing.\n\nOther use case is editing keywords that are passed on the calculators. E.g. you can generate new keyword argument that is then passed to all calculators. This allows you to share e.g. a pairlist between calculators.\n\nTo control what keywords are passed you need to extend generate_keywords function.\n\nFields\n\ncalculators::NTuple{N,Any}  : NTuple that holds calculators\nexecutor::Any               : Transducers executor used to execute calculation - default SequentialEx\nkeywords::Function          : function used to generate keywords for calculators\n\nCreation\n\nCombinationCalculator( calc1, calc2, ...; executor=SequentialEx())\n\n\n\n\n\n","category":"type"},{"location":"#AtomsUtilityCalculators.ReportingCalculator","page":"Home","title":"AtomsUtilityCalculators.ReportingCalculator","text":"ReportingCalculator{T, TC, TF}\n\nReportingCalculator collects information during calculation and sent it to a Channel that can be read.\n\nFields\n\ncalculator::T          : caculator used in calculations\nchannel::Channel{TC}   : Channel where message is put\nmessage::TF            : function that generates the message\n\nCreation\n\nrcalc = ReportingCalculator(calculator, Channel(32))\nrcalc = ReportingCalculator(calculator, Channel(32); message_function=my_message_function)\n\nWhen message_function is omitted, generate_message function is used. See it for more details on how to control generated messages.\n\nYou can access the channel by calling calculator directly with fetch or take!.\n\n\n\n\n\n","category":"type"},{"location":"#AtomsUtilityCalculators.SubSystemCalculator","page":"Home","title":"AtomsUtilityCalculators.SubSystemCalculator","text":"SubSystemCalculator{T, TC}\n\nSubmits subsystem to given calculator.\n\nThe purpose of this calculator is that you can split system to smaller system that can then be calculated with e.g. with different methods. One possible use case here is QM/MM calculations where you can split QM system out.\n\nThe structrure is mutable to allow mutable calculators.\n\nFields\n\ncalculator::T  :  calculator which is used for the subsystem calculation\nsubsys::TC     :  definition of subsystem like array of indices - has to be iterable\n\n\n\n\n\n","category":"type"},{"location":"#AtomsUtilityCalculators.generate_keywords-Tuple{Any, Vararg{Any}}","page":"Home","title":"AtomsUtilityCalculators.generate_keywords","text":"generate_keywords\n\nThis function is called when CombinationCalculator is used.\n\nDefault implementation will only pass keywords forward.\n\nThe call type is AtomsBase system first then all calculators and kwargs. This will allow you to extend based on calculator type.\n\nExample\n\nfunction AtomsUtilityCalculators.generate_keywords(sys, pp1::PairPotential, pp2::PairPotential; kwargs...)\n    if cutoff_radius(pp1) â‰ˆ cutoff_radius(pp2)\n        nlist = PairList(sys, cutoff_radius(pp1))\n        return (; :nlist => nlist, kwargs...)\n    else\n        return kwargs\n    end\nend\n\nwill check that PairPotentials have same cutoff radius. Then calculates pairlist and passes it forward as a keyword. \n\n\n\n\n\n","category":"method"},{"location":"#AtomsUtilityCalculators.generate_message-Tuple{Any, Any, Any}","page":"Home","title":"AtomsUtilityCalculators.generate_message","text":"generate_message(sys, calculator, calc_result; kwargs...) = calc_result\n\nThis is the default function that is called when ReportingCalculator collects a message. Extending this allows you to control what is reported.\n\nThis function is ment to allow setting of global stetting. If you want to set reporting function for an individual case, give ReportingCalculator keyword message_function=my_report where my_report is function that returns your message.\n\nIf function returns nothing the message is ignored. You can use this to control when message is sent. \n\n\n\n\n\n","category":"method"}]
}
